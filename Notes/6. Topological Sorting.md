# 6. Topological Sorting

```
Visit(E, u):
	pre[u] <- T; T <- T+1
	visited[u] <- True
	FOR v in edges[u]:
		IF not visited[v]:
			Visit(v)
	post[u] <- T; T <- T+1
	
DFS(G):
	T <- 1  # Counter
	visited <- [False] * |V|
	FOR u in V:
		IF not visited[u]:
			Visit(u)
```

`pre`: when entered nodes
`post`: when left nodes

**Example pre- and post-order intervals:**

![[top-sort-intervals.jpeg|400]]

Reverse post ordering is topological sort since all the nodes it depends on have been called before.

*Note:* If we're only interested in the topological sort, we don't have to track pre- and post-orderings. We can simply append the node to the topological sort at the point where we set the post order and then reverse the array at the very end.

## Edge Types

Given an edge $(u, v)$, there are 4 different types of edges:

1. Tree edge $\left[ \begin{array}{c} \overset{u}{\longleftarrow\!\!\longrightarrow} \\[-4ex] \overset{v}{\longleftrightarrow} \end{array} \right]$: Edge is traversed by DFS
2. Forward edge $\left[ \begin{array}{c} \overset{u}{\longleftarrow\!\!\longrightarrow} \\[-10ex] \vdots \\ \overset{v}{\longleftrightarrow} \end{array} \right]$: 
   $v$ is a descendant of $u$, but it was already visited through an intermediary descendent of $u$
3. Back edge $\left[ \begin{array}{c} \overset{v}{\longleftarrow\!\!\longrightarrow} \\[-10ex] \vdots \\ \overset{u}{\longleftrightarrow} \end{array} \right]$: 
   $u$ is a descendant of $v$, and the edge $(u,v)$ goes back to an ancestor $\implies$ cycle b/c we can travel from $v$ to $u$ and back again.
4. Cross edge $\left[ \overset{v}{\longleftrightarrow} \overset{u}{\longleftrightarrow} \right]$: $v$ already visited in different DFS subtree. 

$\left[ \overset{u}{\longleftrightarrow} \overset{v}{\longleftrightarrow} \right]$ is impossible b/c $v$ would already be visited in $u$'s recursive call. Overlapping but not nested intervals are impossible due to the recursive nature of DFS.
